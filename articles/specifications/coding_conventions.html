<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Именования | Citrus Engine </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Именования | Citrus Engine ">
      
      <link rel="icon" href="../../images/favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="именования">Именования</h1>

<ul>
<li><p><strong>Всегда</strong>: Используй CamelCase в названиях разныхПеременных, МетодовКлассов и т.д.</p>
</li>
<li><p><strong>Всегда</strong>: Используй заглавные буквы согласно договорённости:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Сущность</th>
<th>Написание</th>
</tr>
</thead>
<tbody>
<tr>
<td>Namespace</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Type (class, struct)</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Method (private, public)</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Property (private, protected, public)</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Event (private, protected, public)</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Delegate (private, protected, public)</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Field (private, protected)</td>
<td>С маленькой буквы</td>
</tr>
<tr>
<td>Field (public)</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Enum value</td>
<td>С большой буквы</td>
</tr>
<tr>
<td>Parameter</td>
<td>С маленькой буквы</td>
</tr>
<tr>
<td>Variable</td>
<td>С маленькой буквы</td>
</tr>
<tr>
<td>Constant (private, protected, public, in-code)</td>
<td>С большой буквы</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>Предпочтительно</strong>: Используй для bool такие названия, чтобы название представляло собой вопрос. Например: <code>IsWidgetHidden</code>, <code>AreTasksComplete</code>, <code>CanPlayerExit</code>.</p>
</li>
<li><p><strong>Нежелательно</strong>: Использовать Венгерскую нотацию или любой другой способ определения типа в идентификаторах.</p>
</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
int iCounter;
string strName;

// Правильно:
int counter;
string name;
</code></pre>
<ul>
<li><strong>Никогда</strong>: Никогда не используй Screaming Caps</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
public static const string SHIPPINGTYPE = &quot;DropShip&quot;;

// Правильно:
public static const string ShippingType = &quot;DropShip&quot;;
</code></pre>
<ul>
<li><p><strong>Нежелательно</strong>: Использовать сокращения, кроме общепринятых аббревиатур.</p>
</li>
<li><p><strong>Всегда</strong>: Капитализируй аббревиатуры так же, как и обычные слова в названиях. Исключение: аббревиатуры, состоящие из 2 букв</p>
</li>
</ul>
<pre><code class="lang-csharp">// Правильные названия:
public string Html;
public object UI;
private int id;
</code></pre>
<ul>
<li><strong>Нежелательно</strong>: Использовать символ подчёркивания и другие неалфавитные символы</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
public DateTime client_Appointment;

// Правильно:
public DateTime clientAppointment;
</code></pre>
<ul>
<li><strong>Никогда</strong>: Никогда не используй символ подчёркивания в начале имени</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
private DateTime _registrationDate;

// Правильно:
private DateTime registrationDate;
</code></pre>
<ul>
<li><strong>Всегда</strong>: Начинай название интерфейса с буквы <code>I</code></li>
</ul>
<pre><code class="lang-csharp">// Правильно:
public interface IShape
{
}
</code></pre>
<ul>
<li><p><strong>Предпочтительно</strong>: Использовать названия файлов, соответствующие названию главного класса в них.</p>
</li>
<li><p><strong>Всегда</strong>: Синхронизируй структуру файлов и структуру неймспесов</p>
</li>
</ul>
<pre><code class="lang-csharp">// ProjectFolder/Main.cs:
namespace Project
{
  class Main { ... }
}

// ProjectFolder/Module/ClassA.cs:
namespace Project.Module
{
  class ClassA { ... }
}

// ProjectFolder/Module/Submodule/ClassB.cs:
namespace Project.Module.Submodule
{
  class ClassB { ... }
}
</code></pre>
<ul>
<li><strong>Всегда</strong>: Используй названия в единственном числе для <code>enum</code> и в множественном числе для <code>Flags</code></li>
</ul>
<pre><code class="lang-csharp">public enum Color
{
  Red,
  Green,
  Blue,
}

[Flags]
public enum Dockings
{
  None = 0,
  Top = 1,
  Right = 2,
  Bottom = 4,
  Left = 8,
}
</code></pre>
<ul>
<li><strong>Никогда</strong>: Никогда не используй обрезанные слова в названиях</li>
</ul>
<pre><code class="lang-csharp">// Неправильно
GetWin

// Правильно:
GetWindow
</code></pre>
<ul>
<li><p><strong>Всегда</strong>: Используй следующие стандартные имена аргументов:</p>
<ul>
<li>Унарный оператор - <code>value</code></li>
<li>Equals-подобный метод - <code>other</code></li>
<li>Бинарный оператор - <code>lhs</code>, <code>rhs</code></li>
<li>Метод с N параметрами одинакового типа: <code>value1</code>, <code>value2</code>, ..., <code>valueN</code></li>
</ul>
</li>
<li><p><strong>Всегда</strong>: Называй ивенты следующим образом:</p>
<ul>
<li>Заканчивай название на <code>-ing</code>, если ивент вызывается до или во время главного действия.</li>
<li>Заканчивай название на <code>-ed</code>, если ивент вызывается после главного действия. (имеется в виду past participle т.е. третья форма для irregular verbs)</li>
<li>Заканчивай название метода на <code>_EventName</code>, если он присваивается ивенту с названием <code>EventName</code>.</li>
<li>Называй метод <code>OnEventName</code>, если он вызывает ивент с названием <code>EventName</code>.</li>
</ul>
</li>
</ul>
<pre><code class="lang-csharp">class A
{
  public delegate void UpdateDelegate();
  public event UpdateDelegate Updating;
  public event UpdateDelegate Updated;
  
  private void Update()
  {
    OnUpdating();
    // ...
    OnUpdated();
  }

  private void OnUpdating()
  {
    Updating();
  }

  private void OnUpdated()
  {
    Updated();
  }
}

class MyWidget
{
  private void Method()
  {
    a.Updating += MyWidget_Updating;
    a.Updated += MyWidget_Updated;
  }
}
</code></pre>
<ul>
<li><p><strong>Всегда</strong>: называй переменные означающие количество чего-либо в стиле <code>&lt;something&gt;Count</code>, где <code>&lt;something&gt;</code> в единственном числе.</p>
</li>
<li><p><strong>Всегда</strong>: называй переменные индекса как <code>index</code> или <code>&lt;something&gt;</code>Index, если это не сокращённая форма (i, j, k, etc)</p>
</li>
<li><p><strong>Предпочитительно</strong>: формируй имена переменных и методов в стиле естественных языков:</p>
</li>
</ul>
<pre><code class="lang-csharp">// Правильно:
var shortName = &quot;Leo&quot;;
var fullName = &quot;Leonardo&quot;;

// Неправильно:
var nameFull = &quot;Donatello&quot;;
var nameShort = &quot;Don&quot;;
</code></pre>
<ul>
<li><strong>Всегда</strong>: добавляй к методу префикс <code>try</code> если выполняются следующие пункты:
<ol>
<li>обязательно: метод возвращает <code>bool</code></li>
<li>обязательно: если от метода ожидается возвращемое значение, то оно получается через <code>out</code></li>
<li>обязательно: метод не бросит исключений.</li>
<li>желательно: есть такой же метод без <code>try</code>, в случае неудачи бросающий исключение.</li>
</ol>
</li>
</ul>
<h1 id="оформление-комментариев">Оформление комментариев</h1>
<ul>
<li><strong>Всегда</strong>: Пиши комментарии на английском языке.</li>
<li><strong>Предпочтительно</strong>: Располагать комментарий на предыдущей строке, а не в конце строки комментируемого кода.</li>
<li><strong>Всегда</strong>: Начинай комментарий с заглавной буквы и заканчивай точкой.</li>
<li><strong>Всегда</strong>: Вставляй пробел между символами комментария <code>//</code> и текстом комментария</li>
</ul>
<pre><code class="lang-csharp">// Правильно:
// The following declaration creates a query. It does not run 
// the query.
</code></pre>
<ul>
<li><strong>Никогда</strong>: Никогда не создавай форматированные блоки звёздочек вокруг комментариев</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
//****************************
//*  Very important comment  *
//****************************

// Правильно:
// Very important comment
</code></pre>
<ul>
<li><strong>Предпочтительно</strong>: Указывать автора в тексте комментари</li>
</ul>
<pre><code class="lang-csharp">// Правильно:
// Linus Torvalds: this method was not implemented
// because it would take too much time.
</code></pre>
<ul>
<li><strong>Всегда</strong>: Оставляй комментарий, если вкручиваешь костыль или реализуешь какую-то неочевидную логику.</li>
<li><strong>Никогда</strong>: Никогда не используй комментарии в блоках <code>/**/</code>.</li>
</ul>
<h1 id="форматирование">Форматирование</h1>
<ul>
<li><p><strong>Всегда</strong>: Используй табуляцию вместо пробелов для отступов.</p>
</li>
<li><p><strong>Всегда</strong>: Используй пробелы вместо табуляции для выравнивания.</p>
</li>
<li><p><strong>Всегда</strong>: Используй вертикальное выравнивание скобочек вместо египетского выравнивания.
Исключения:</p>
<ul>
<li>if</li>
<li>циклы</li>
<li>switch</li>
<li>object and collection initializers</li>
<li>lambda expressions</li>
</ul>
</li>
<li><p><strong>Всегда</strong>: Вставляй пробелы между бинарными операторами и операндами.</p>
</li>
<li><p><strong>Всегда</strong>: Для однострочных лямбд, object and collection initializers отделяй внутреннюю часть от фигурных скобок одним пробелом.</p>
</li>
<li><p><strong>Всегда</strong>: Отделяй <code>[]</code> пробелом справа и не отделяй слева, в синтаксисе объявлений и инициализаций.</p>
</li>
</ul>
<pre><code class="lang-csharp">// Правильно:
int[] dogs = new int[] { 1, 2, 3 };
// Не правильно:
int [] dogs = new int [] { 1, 2, 3 };
</code></pre>
<ul>
<li><strong>Предпочтительно</strong>: Использовать LINQ в виде цепочек методов, а не sql-подобные LINQ вызовы</li>
</ul>
<pre><code class="lang-csharp">// Нежелательно:
var names = from item in collection
            select item.Name;

// Желательно:
var names = collection
            .Select(item =&gt; item.Name);
</code></pre>
<ul>
<li><strong>Всегда</strong>: Форматируй switch statement согласно следующим правилам:
<ul>
<li>однострочные <code>case</code> допустимы, если тело <code>case</code> из одной строчки считая <code>break</code></li>
<li>вставляй отступ перед case</li>
<li>если тело case обрамляется в фигурные скобки, то откывающая скобка должна быть расположена на одной строчке с case, а закрывающая на отдельной строчке, на уровне вложенности соответствующего case; <code>break</code> или <code>return</code> в таком случае должен оставаться внутри фигурных скобок</li>
</ul>
</li>
</ul>
<p>Примеры правильного форматирования <code>switch</code> statement:</p>
<pre><code class="lang-csharp">public List&lt;ChestBonusConfig&gt; Config
{
  get
  {
    switch (Kind) {
      case SlotKind.StarterPack: return The.Config.StarterPackContents;
      case SlotKind.ProductPack: return The.Config.GetProductPackConfig(Index);
      case SlotKind.CoinPack: case SlotKind.ButtonMore: return null;
      default: throw new ArgumentOutOfRangeException();
    }
  }
}

private Widget GetBasicWidget()
{
  switch (ParticlesLinkage) {
    case ParticlesLinkage.Parent:
      return ParentWidget;
    case ParticlesLinkage.Other: {
      var widget = ParentWidget;
      while (widget != null) {
        if (widget.Id == LinkageWidgetName) {
            return widget;
        }
        widget = widget.ParentWidget;
      }
      return null;
    }
    case ParticlesLinkage.Root:
    default:
      return (Parent != null) ? WidgetContext.Current.Root : null;
}

switch (type) {
  case SignatureType.BinaryUnordered:
    yd = new BinaryDeserializer {
      Options = defaultYuzuCommonOptions,
      BinaryOptions = new BinarySerializeOptions { Unordered = true },
    };
    break;
  case SignatureType.BinaryOrdered:
    yd = new BinaryDeserializer {
      Options = defaultYuzuCommonOptions,
    };
    break;
  case SignatureType.Json:
    SkipBomIfPresent(ms);
    yd = new JsonDeserializer {
      JsonOptions = defaultYuzuJSONOptions,
      Options = defaultYuzuCommonOptions
    };
    break;
  default:
    throw new System.Exception(&quot;Unexpected Case&quot;);
}
</code></pre>
<ul>
<li><strong>Всегда</strong>: Используй кодировку UTF-8.</li>
</ul>
<h1 id="расположение-и-структура-кода">Расположение и структура кода</h1>
<ul>
<li><strong>Всегда</strong>: Пиши только одно выражение в строке</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
a = 5; b = &quot;kek&quot;; c = new Example(a, b);

// Правильно:
a = 5; 
b = &quot;kek&quot;; 
c = new Example(a, b);
</code></pre>
<ul>
<li><strong>Всегда</strong>: Пиши только одно объявление в строке</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
int a, b; string c; char d;

// Правильно:
int a; 
int b; 
string c; 
char d;
</code></pre>
<ul>
<li><strong>Нежелательно</strong>: Писать выражения на одной строке с if</li>
</ul>
<pre><code class="lang-csharp">// Нежелательно:
if (true) return;

// Желательно:
if (true){
  return;
}
</code></pre>
<ul>
<li><strong>Предпочтительно</strong>: Оборачивать даже однострочные выражения в фигурные скобки</li>
</ul>
<pre><code class="lang-csharp">// Нежелательно:
if (true)
  return;

// Желательно:
if (true){
  return;
}
</code></pre>
<ul>
<li><p><strong>Всегда</strong>: Добавляй одну пустую строку между объявлениями методов и свойств.</p>
</li>
<li><p><strong>Нежелательно</strong>: Писать строки длиннее 100 символов.</p>
</li>
<li><p><strong>Никогда</strong>: Никогда не пиши строк длиннее 120 символов.</p>
</li>
<li><p><strong>Всегда</strong>: Оставляй перенос на новую строку в конце файла.</p>
</li>
<li><p><strong>Всегда</strong>: Оставляй бинарный оператор на той же строке, что и первый операнд.</p>
</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
var a = 
  someLongLongLongLongLongLongLongVariableName1 
  || someLongLongLongLongLongLongLongVariableName2;

// Правильно:
var a = 
  someLongLongLongLongLongLongLongVariableName1 ||
  someLongLongLongLongLongLongLongVariableName2;
</code></pre>
<ul>
<li><strong>Всегда</strong>: Добавляй перенос строки между return и длинным выражением.</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
return someLongLongLongLongLongLongLongVariableName1 ||
  someLongLongLongLongLongLongLongVariableName2;

// Правильно:
return 
  someLongLongLongLongLongLongLongVariableName1 ||
  someLongLongLongLongLongLongLongVariableName2;
</code></pre>
<ul>
<li><strong>Всегда</strong>: Располагай длинные выражения отдельно от if и скобочек.</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
if (someLongLongLongLongLongLongLongVariableName1 ||
  someLongLongLongLongLongLongLongVariableName2) {
  ...
}

// Правильно:
if (
  someLongLongLongLongLongLongLongVariableName1 ||
  someLongLongLongLongLongLongLongVariableName2
) {
  ...
}
</code></pre>
<h1 id="использование-языка">Использование языка</h1>
<ul>
<li><strong>Всегда</strong>: Используй обобщённые названия типов вместо системных типов, таких как <code>Int16</code>, <code>Single</code>, <code>UInt64</code> и т.д.</li>
</ul>
<pre><code class="lang-csharp">// Неправильно:
String firstName;
Int32 lastIndex;
Boolean isSaved;

// Правильно:
string firstName;
int lastIndex;
bool isSaved;
</code></pre>
<ul>
<li><strong>Всегда</strong>: Используй <code>var</code> для всех типов кроме простых.</li>
<li><strong>Нежелательно</strong>: Использовать var для простых типов.</li>
<li><strong>Всегда</strong>: Явно указывай модификатор доступа <code>private</code>.</li>
<li><strong>Нежелательно</strong>: Использовать директиву <code>#region</code>.</li>
<li><strong>Предпочтительно</strong>: Использовать авто-свойства (Auto-Implemented Properties) вместо public полей.</li>
<li><strong>Всегда</strong>: дополняй окончания блочных директив препроцессора комментарием, дублирующим выражение в первой директиве данного блока в той же строке.</li>
</ul>
<pre><code class="lang-csharp">// Например
#if ANDROID &amp;&amp; BFG_LIB
      Lime.Application.DiscardOpenGLObjects();
#endif // ANDROID &amp;&amp; BFG_LIB
</code></pre>
<ul>
<li><strong>Желательно</strong>: Указывать имя параметра в месте вызова, если параметр типа <code>bool</code></li>
</ul>
<pre><code class="lang-csharp">// Например
void Func(bool flag) {}
Func(flag: true);
</code></pre>
<h1 id="документация">Документация</h1>
<ul>
<li><p><strong>Предпочтительно</strong>: Использовать следующие тэги:</p>
<ul>
<li><code>&lt;param&gt;</code></li>
<li><code>&lt;see&gt;</code></li>
<li><code>&lt;summary&gt;</code></li>
</ul>
</li>
<li><p><strong>Никогда</strong>: Никогда не используй тэг <code>&lt;see&gt;</code> в комментарии более одного раза.</p>
</li>
</ul>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          GameForest 2024
        </div>
      </div>
    </footer>
  </body>
</html>
